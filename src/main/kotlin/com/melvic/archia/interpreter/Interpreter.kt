package com.melvic.archia.interpreter

import com.melvic.archia.ast.*
import com.melvic.archia.ast.compound.BoolQuery
import com.melvic.archia.ast.compound.BoostingQuery
import com.melvic.archia.ast.compound.ConstantScoreQuery
import com.melvic.archia.ast.compound.DisMaxQuery
import com.melvic.archia.ast.leaf.*
import com.melvic.archia.output.*
import kotlin.reflect.KCallable

typealias Evaluation = Result<JsonValue>

fun interpret(init: Init<Query>) = buildQuery(init).interpret()

fun Query.interpret(): Evaluation {
    val output = this.queryClause?.interpret() ?: missingField(this::query)

    return when (output) {
        is Failed -> output
        is Success<*> -> json {
            "query" to output.value()
        }.success()
    }
}

fun Clause.interpret(parent: JsonValue = json {}): Evaluation {
    val parentObject = if (parent is JsonObject) parent else json {}

    return when (this) {
        is TermQuery -> interpret(parentObject)
        is MatchQuery -> interpret(parentObject)
        is MatchAllQuery -> interpret(parentObject)
        is MatchNoneQuery -> interpret(parentObject)
        is RangeQuery -> interpret(parentObject)
        is BoolQuery -> interpret(parentObject)
        is BoostingQuery -> interpret(parentObject)
        is ConstantScoreQuery -> interpret(parentObject)
        is DisMaxQuery -> interpret(parentObject)
        else -> json {}.success()
    }
}

fun TermQuery.interpret(parent: JsonObject): Evaluation {
    val field = this.field ?: return missingField(this::field)
    if (field.value == null) return missingField(field::value)

    val termFieldOut = json {
        customProp?.let {
            it.first to it.second.json()
        } ?: field.name to json {
            prop(field::value) { it.json() }
            prop(field::boost) { it.json() }
        }
    }

    val termOut = parent { esName() to termFieldOut }
    return termOut.success()
}

fun MatchQuery.interpret(parent: JsonObject): Evaluation {
    val field = this.field ?: return missingField(this::field)
    if (field.query == null) return missingField(field::query)

    val matchFieldOut = with(field) {
        json {
            prop(::query) {
                when (it) {
                    is AString -> it.value.json()
                    is ANumber -> it.value.json()
                    is ABoolean -> it.value.json()
                    is ADate -> it.value.toString().json()
                    else -> JsonNull
                }
            }
            prop(::analyzer) { it.json() }
            prop(::autoGeneratedSynonymsPhraseQuery) { it.json() }
            prop(::fuzziness) {
                when (it) {
                    is Fuzziness._0 -> 0.json()
                    is Fuzziness._1 -> 1.json()
                    is Fuzziness._2 -> 2.json()
                    is Fuzziness.Auto -> it.distances?.let { distances ->
                        val (low, high) = distances
                        "AUTO:[$low],[$high]".json()
                    } ?: "AUTO".json()
                }
            }
            prop(::maxExpansions) { it.json() }
            prop(::prefixLength) { it.json() }
            prop(::transpositions) { it.json() }
            propEnum(::fuzzyRewrite)
            prop(::lenient) { it.json() }
            propEnum(::operator)
            prop(::minimumShouldMatch) { it.interpret(this) }
            propEnum(::zeroTermsQuery)
        }
    }

    val matchOut = parent { esName() to json { field.name to matchFieldOut } }
    return matchOut.success()
}

fun MatchAllQuery.interpret(parent: JsonObject): Evaluation {
    return parent {
        esName() to json { prop(::boost) { it.json() } }
    }.success()
}

fun MatchNoneQuery.interpret(parent: JsonObject): Evaluation {
    return parent { esName() to json {} }.success()
}

fun RangeQuery.interpret(parent: JsonObject): Evaluation {
    val field = this.field ?: return missingField(this::field)

    val rangeFieldOut = with(field) {
        json {
            fun <R, C : KCallable<R>> propFieldParam(callable: C) {
                prop(callable) {
                    when (it) {
                        is ANumber -> it.value.json()
                        is DateFormat -> it.lowerName().json()
                        else -> JsonNull
                    }
                }
            }
            propFieldParam(::gt)
            propFieldParam(::gte)
            propFieldParam(::lt)
            propFieldParam(::lte)

            propEnum(::format)
            propEnum(::relation)
            prop(::timeZone) { it.json() }
            prop(::boost) { it.json() }
        }
    }

    val rangeOut = parent { esName() to json { field.name to rangeFieldOut } }
    return rangeOut.success()
}

fun BoolQuery.interpret(parent: JsonObject): Evaluation {
    val propsOut = json {
        propWithAlt(::_must, ::must) { it.interpret() }
        propWithAlt(::_should, ::should) { it.interpret() }
        propWithAlt(::_filter, ::filter) { it.interpret() }
        propWithAlt(::_mustNot, ::mustNot) { it.interpret() }
        prop(::minimumShouldMatch) { it.interpret(this) }
        prop(::boost) { it.json() }
    }
    val boolOut = parent { esName() to propsOut }
    return boolOut.validate()
}

fun BoostingQuery.interpret(parent: JsonObject): Evaluation {
    if (_positive == null) return missingField(::positive)
    if (_negative == null) return missingField(::negative)

    val propsOut = json {
        propWithAlt(::_positive, ::positive) { it.interpret() }
        propWithAlt(::_negative, ::negative) { it.interpret() }
        prop(::negativeBoost) { it.json() }
    }

    val boostingOut = parent { esName() to propsOut }
    return boostingOut.success()
}

fun ConstantScoreQuery.interpret(parent: JsonObject): Evaluation {
    if (_filter == null) return missingField(::filter)

    return parent {
        esName() to json {
            propWithAlt(::_filter, ::filter) { it.interpret() }
            prop(::boost) { it.json() }
        }
    }.success()
}

fun DisMaxQuery.interpret(parent: JsonObject): Evaluation {
    if (_queries == null) return missingField(::queries)

    return parent {
        esName() to json {
            propWithAlt(::_queries, ::queries) { it.interpret() }
            prop(::tieBreaker) { it.json() }
        }
    }.success()
}

fun MultiClause.interpret(): Evaluation {
    if (this.size == 1)
        return this[0].interpret()

    val result: JsonArray = jsonArray()

    for (clause in this) {
        val eval = clause.interpret()
        if (eval is Failed) return eval
        result.add(eval.value())
    }

    return result.success()
}

fun MinimumShouldMatch.interpret(parent: JsonObject): JsonValue {
    val msm: MinimumShouldMatch = this
    return with(parent) {
        fun interpretSimple(it: SimpleMSM): JsonValue = when (it) {
            is ANumber -> it.value.json()
            is Percent -> "${it.value}%".json()
            else -> JsonNull
        }
        fun interpretMin(it: MinimumShouldMatch): JsonValue = when (it) {
            is SimpleMSM -> interpretSimple(it)
            is Combination -> "${it.value}<${interpretSimple(it.simple)}".json()
            is Multiple -> array(it.values.map { i -> interpretMin(i) })
            else -> JsonNull
        }
        interpretMin(msm)
    }
}
