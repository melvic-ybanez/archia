@file:Suppress("MoveSuspiciousCallableReferenceIntoParentheses")

package com.melvic.archia.interpreter.fulltext

import com.melvic.archia.ast.ABoolean
import com.melvic.archia.ast.ADate
import com.melvic.archia.ast.ANumber
import com.melvic.archia.ast.AString
import com.melvic.archia.ast.fulltext.*
import com.melvic.archia.interpreter.*
import com.melvic.archia.output.*
import com.melvic.archia.require
import com.melvic.archia.validate

fun MatchQuery.interpret(parent: JsonObject): Evaluation {
    fun JsonObject.toJson(query: MatchQueryValue): JsonValue {
        return when (query) {
            is AString -> query.value.json()
            is ANumber -> query.value.json()
            is ABoolean -> query.value.json()
            is ADate -> query.value.toString().json()
            else -> JsonNull
        }
    }

    val namedPropOut = namedProp?.let {
        val jsonObj = json {}
        jsonObj { it.first to toJson(it.second) }
    }

    return withField(parent, namedProp = namedPropOut, required = { ::query }) {
        json {
            prop(::query) { toJson(it) }
            propStr(::analyzer)
            propBool(::autoGeneratedSynonymsPhraseQuery)
            prop(::fuzziness) { it.interpret(this) }
            propNum(::maxExpansions)
            propNum(::prefixLength)
            propBool(::transpositions)
            propEnum(::fuzzyRewrite)
            propBool(::lenient)
            propEnum(::operator)
            prop(::minimumShouldMatch) { it.interpret(this) }
            propEnum(::zeroTermsQuery)
        }
    }
}

fun MatchAllQuery.interpret(parent: JsonObject): Evaluation {
    return parent {
        esName() to json { prop(::boost) { it.json() } }
    }.success()
}

fun MatchNoneQuery.interpret(parent: JsonObject): Evaluation {
    return parent { esName() to json {} }.success()
}

fun MatchBoolPrefixQuery.interpret(parent: JsonObject): Evaluation {
    return withField(parent, required = { ::query }) {
        json {
            propStr(::query)
            propStr(::analyzer)
            prop(::minimumShouldMatch) { it.interpret(this) }
            propEnum(::operator)
        }
    }
}

fun MatchPhraseQuery.interpret(parent: JsonObject): Evaluation {
    return withField(parent, required = { ::query }) {
        json {
            propStr(::query)
            propStr(::analyzer)
            propEnum(::zeroTermsQuery)
        }
    }
}

fun MatchPhrasePrefixQuery.interpret(parent: JsonObject): Evaluation {
    return withField(parent, required = { ::query }) {
        json {
            propStr(::query)
            propStr(::analyzer)
            propNum(::maxExpansions)
            propNum(::slop)
            propEnum(::zeroTermsQuery)
        }
    }
}

fun MultiMatchQuery.interpret(parent: JsonObject): Evaluation {
    return parent {
        esName() to require(::query) {
            propArray(::fields)
            propNum(::tieBreaker)
            propStr(::analyzer)
            propNum(::boost)
            propBool(::lenient)
            propEnum(::zeroTermsQuery)
            prop(::fuzziness) { it.interpret(this) }
            propNum(::maxExpansions)
            propEnum(::operator)
            prop(::minimumShouldMatch) { it.interpret(this) }
            propNum(::cutoffFrequency)
            propNum(::prefixLength)
            propEnum(::rewrite)
            propBool(::autoGeneratedSynonymsPhraseQuery)
            propBool(::fuzzyTranspositions)
            propNum(::slop)
        }
    }.validate()
}