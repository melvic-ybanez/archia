package com.melvic.archia.interpreter

import com.melvic.archia.ast.*
import com.melvic.archia.ast.leaf.*
import com.melvic.archia.output.*
import kotlin.reflect.KCallable

fun TermQuery.interpret(parent: JsonObject): Evaluation {
    val namedPropOut = namedProp?.let {
        json { it.first to it.second.json() }
    }

    return withField(parent, namedProp = namedPropOut) inner@ {
        if (value == null) return@inner json {
            error(missingFieldCode(::value))
        }

        json {
            prop(::value) { it.json() }
            prop(::boost) { it.json() }
        }
    }
}

fun MatchQuery.interpret(parent: JsonObject): Evaluation {
    fun JsonObject.toJson(query: MatchQueryValue): JsonValue {
        return when (query) {
            is AString -> query.value.json()
            is ANumber -> query.value.json()
            is ABoolean -> query.value.json()
            is ADate -> query.value.toString().json()
            else -> JsonNull
        }
    }

    val namedPropOut = namedProp?.let {
        val jsonObj = json {}
        jsonObj { it.first to toJson(it.second) }
    }

    return withField(parent, namedProp = namedPropOut) inner@ {
        if (query == null) return@inner json {
            error(missingFieldCode(::query))
        }

        json {
            prop(::query) { toJson(it) }
            prop(::analyzer) { it.json() }
            prop(::autoGeneratedSynonymsPhraseQuery) { it.json() }
            prop(::fuzziness) { it.interpret(this) }
            prop(::maxExpansions) { it.json() }
            prop(::prefixLength) { it.json() }
            prop(::transpositions) { it.json() }
            propEnum(::fuzzyRewrite)
            prop(::lenient) { it.json() }
            propEnum(::operator)
            prop(::minimumShouldMatch) { it.interpret(this) }
            propEnum(::zeroTermsQuery)
        }
    }
}

fun MatchAllQuery.interpret(parent: JsonObject): Evaluation {
    return parent {
        esName() to json { prop(::boost) { it.json() } }
    }.success()
}

fun MatchNoneQuery.interpret(parent: JsonObject): Evaluation {
    return parent { esName() to json {} }.success()
}

fun RangeQuery.interpret(parent: JsonObject): Evaluation {
    return withField(parent) {
        json {
            fun <R, C : KCallable<R>> propFieldParam(callable: C) {
                prop(callable) {
                    when (it) {
                        is ANumber -> it.value.json()
                        is DateFormat -> it.lowerName().json()
                        else -> JsonNull
                    }
                }
            }
            propFieldParam(::gt)
            propFieldParam(::gte)
            propFieldParam(::lt)
            propFieldParam(::lte)

            propEnum(::format)
            propEnum(::relation)
            prop(::timeZone) { it.json() }
            prop(::boost) { it.json() }
        }
    }
}