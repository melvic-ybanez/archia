package com.melvic.archia.leaf

import com.melvic.archia.Fuzziness
import com.melvic.archia.MinimumShouldMatch
import com.melvic.archia.Query
import com.melvic.archia.Rewrite
import java.util.*

class Match : Query() {
    var field: MatchField? = null

    /**
     * Constructs a match field from a string
     */
    operator fun String.invoke(init: MatchField.() -> Unit): MatchField =
        MatchField(this).apply(init)
}

data class MatchField(val name: String) {
    var query: MatchQueryValue? = null
    var analyzer: String? = null
    var autoGeneratedSynonymsPhraseQuery: Boolean? = null
    var fuzziness: Fuzziness? = null
    var maxExpansions: Int? = null
    var prefixLenth: Int? = null
    var transpositions: Boolean? = null
    var fuzzyRewrite: Rewrite? = null
    var lenient: Boolean? = null
    var operator: FieldOperator? = null
    var minimumShouldMatch: MinimumShouldMatch? = null
    var zeroTermsQuery: ZeroTermsQuery? = null

    fun text(value: String) = MatchQueryValue.TextValue(value)
    fun num(value: Number) = MatchQueryValue.NumberValue(value)
    fun bool(value: Boolean) = MatchQueryValue.BooleanValue(value)
    fun date(value: Date) = MatchQueryValue.DateValue(value)
}

sealed class MatchQueryValue {
    data class TextValue(val value: String) : MatchQueryValue()
    data class NumberValue(val value: Number) : MatchQueryValue()
    data class BooleanValue(val value: Boolean) : MatchQueryValue()
    data class DateValue(val value: Date) : MatchQueryValue()
}

enum class FieldOperator { OR, AND }
enum class ZeroTermsQuery { NONE, ALL }
