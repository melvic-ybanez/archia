package com.melvic.archia.interpreter

import com.melvic.archia.*
import com.melvic.archia.leaf.*
import com.melvic.archia.output.JsonNumber
import com.melvic.archia.output.JsonObject
import com.melvic.archia.output.JsonValue
import com.melvic.archia.output.json
import java.lang.Exception

typealias Evaluation = Result<JsonValue>

fun interpret(query: Query): Evaluation {
    fun interpret(query: Clause, parent: JsonValue): Evaluation {
        val objectOrEmpty = if (parent is JsonObject) parent else json {}

        return when (query) {
            is Term -> query.interpret(objectOrEmpty)
            is Match -> query.interpret(objectOrEmpty)
            else -> Success(json {})
        }
    }

    val output = query.queryClause?.let {
        var result: Evaluation = Success(json {})

        for (child in it.children) {
            if (result is Failed) break
            result = interpret(child, result.value())
        }

        result
    } ?: return Failed(missingField(query::query))

    return when (output) {
        is Failed -> output
        is Success<*> -> Success(json {
            "query" to output.value()
        })
    }
}

fun Term.interpret(parent: JsonObject): Evaluation {
    val field = this.field ?: return Failed(missingField(this::field))

    val termFieldOut = json {
        nameOf(field::value) to text(field.value)
        field.boost?.let { "boost" to num(it) }
    }

    val termOut = parent { "term" to json { field.name to termFieldOut } }
    return Success(termOut)
}

fun Match.interpret(parent: JsonObject): Evaluation {
    val field = this.field ?: return Failed(missingField(this::field))
    if (field.query == null) return Failed(missingField(field::query))

    val matchFieldOut = with(field) {
        json {
            prop(::query) {
                when (it) {
                    is MatchQueryValue.Text -> text(it.value)
                    is MatchQueryValue.Number -> num(it.value)
                    is MatchQueryValue.Boolean -> bool(it.value)
                    is MatchQueryValue.Date -> text(it.value.toString())
                }
            }
            prop(::analyzer) { text(it) }
            prop(::autoGeneratedSynonymsPhraseQuery) { bool(it) }
            prop(::fuzziness) {
                when (it) {
                    is Fuzziness._0 -> num(0)
                    is Fuzziness._1 -> num(1)
                    is Fuzziness._2 -> num(2)
                    is Fuzziness.Auto -> it.distances?.let { distances ->
                        val (low, high) = distances
                        text("AUTO:[$low],[$high]")
                    } ?: text("AUTO")
                }
            }
            prop(::maxExpansions) { num(it) }
            prop(::prefixLength) { num(it) }
            prop(::transpositions) { bool(it) }
            prop(::fuzzyRewrite) { text(it.lowerName()) }
            prop(::lenient) { bool(it) }
            prop(::operator) { text(it.lowerName()) }
            prop(::minimumShouldMatch) {
                fun interpretSimple(it: MinimumShouldMatch.Simple): JsonValue = when (it) {
                    is MinimumShouldMatch.Number -> num(it.value)
                    is MinimumShouldMatch.Percent -> text("${it.value}%")
                    else -> throw Exception("Unrecognized simple match type")
                }
                fun interpretMin(it: MinimumShouldMatch): JsonValue = when (it) {
                    is MinimumShouldMatch.Simple -> interpretSimple(it)
                    is MinimumShouldMatch.Combination -> text("${it.value}<${interpretSimple(it.simple)}")
                    is MinimumShouldMatch.Multiple -> array(it.values.map { i -> interpretMin(i) })
                    else -> throw Exception("Unrecognized match type")
                }
                interpretMin(it)
            }
        }
    }

    val matchOut = parent { "match" to json { field.name to matchFieldOut } }
    return Success(matchOut)
}