package com.melvic.archia.interpreter

import com.melvic.archia.Clause
import com.melvic.archia.Query
import com.melvic.archia.leaf.*
import com.melvic.archia.output.JsonObject
import com.melvic.archia.output.JsonValue
import com.melvic.archia.output.json

typealias Evaluation = Result<JsonValue>

fun interpret(query: Query): Evaluation {
    fun interpret(query: Clause, parent: JsonValue): Evaluation {
        val objectOrEmpty = if (parent is JsonObject) parent else json {}

        return when (query) {
            is Term -> interpretTerm(query, objectOrEmpty)
            else -> Success(json {})
        }
    }

    val output = query.queryClause?.let {
        var result: Evaluation = Success(json {})

        for (child in it.children) {
            if (result is Failed) break
            result = interpret(child, result.value())
        }

        result
    } ?: return Failed(missingField(query::query))

    return when (output) {
        is Failed -> output
        is Success<*> -> Success(json {
            "query" to output.value()
        })
    }
}

fun interpretTerm(term: Term, parent: JsonObject): Evaluation {
    val field = term.field ?: return Failed(missingField(term::field))

    val termFieldOut = json {
        nameOf(field::value) to str(field.value)
        field.boost?.let { "boost" to num(it) }
    }

    val termOut = parent { "term" to json { field.name to termFieldOut } }
    return Success(termOut)
}

fun interpretMatch(match: Match, parent: JsonObject): Evaluation {
    val field = match.field ?: return Failed(missingField(match::field))
    val query = field.query ?: return Failed(missingField(field::query))

    val matchFieldOut = with(field) {
        json {
            nameOf(::query) to when (query) {
                is TextValue -> str(query.value)
                is NumberValue -> num(query.value)
                is BooleanValue -> bool(query.value)
                is DateValue -> str(query.value.toString())
            }
            analyzer?.let { nameOf(::analyzer) to it }
            autoGeneratedSynonymsPhraseQuery?.let {
                nameOf(::autoGeneratedSynonymsPhraseQuery).camelToSnakeCase() to it
            }
        }
    }

    val matchOut = parent { "match" to json { field.name to matchFieldOut } }
    return Success(matchOut)
}